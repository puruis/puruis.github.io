<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FS&#39;Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://puruis.github.io/"/>
  <updated>2019-03-29T02:10:16.355Z</updated>
  <id>https://puruis.github.io/</id>
  
  <author>
    <name>purui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Keepalived + Nginx + Tomcat 搭建高可用负载均衡架构</title>
    <link href="https://puruis.github.io/2019-03-28-Keepalived%20+%20Nginx%20+%20Tomcat%20%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%94%A8%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9E%B6%E6%9E%84/"/>
    <id>https://puruis.github.io/2019-03-28-Keepalived + Nginx + Tomcat 搭建高可用负载均衡架构/</id>
    <published>2019-03-27T16:00:00.000Z</published>
    <updated>2019-03-29T02:10:16.355Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><blockquote><p>初期的互联网企业由于业务量较小，所以一般单机部署，实现单点访问即可满足业务的需求，这也是最简单的部署方式，但是随着业务的不断扩大，系统的访问量逐渐的上升，单机部署的模式已无法承载现有的业务量，需要进行服务集群化部署，本文主要介绍服务端Tomcat多实例部署，以及如何保证web服务的高可用方案。</p></blockquote><ol><li>Nginx 是一个高性能的 HTTP反向代理服务器</li><li>Keepalived 是一个基于VRRP协议来实现的LVS服务高可用方案，可以利用其来避免服务的单点故障</li><li>Tomcat 是一个免费的开放源代码的Web 应用服务器，属于轻量级应用服务器。</li></ol><h1 id="Nginx的高可用负载均衡架构"><a href="#Nginx的高可用负载均衡架构" class="headerlink" title="Nginx的高可用负载均衡架构"></a>Nginx的高可用负载均衡架构</h1><p>如下图：为典型的Tomcat服务多实例部署的架构图</p><blockquote><p>（1）用户通过域名请求到DNS，由DNS解析域名后返回对应的IP地址，该IP及为Keepalived映射服务器的虚拟IP</p></blockquote><blockquote><p>（2）通过该虚拟IP访问到对应的负载均衡器（Nginx），这里Nginx部署两个，然后通过Keepalived来保证NG的高可用，正常情况下由Keepalived-M将虚拟IP映射转发至Nginx-M，如果Nginx-M出现故障，此时Keepalived会切换至Keepalived-S开始工作，从而保证了NG的单点故障问题。</p></blockquote><blockquote><p>（3）通过Nginx负载均衡器，将请求路由到对应的Tomcat服务。</p></blockquote><h2 id="需要准备的软件"><a href="#需要准备的软件" class="headerlink" title="需要准备的软件"></a>需要准备的软件</h2><ol><li>apache-tomcat-8.5.39</li><li>jdk1.8.0_201</li><li>keepalived-1.3.9</li><li>nginx-1.12.2</li></ol><p>以上是我测试时 用的软件版本</p><h2 id="需要准备的环境"><a href="#需要准备的环境" class="headerlink" title="需要准备的环境"></a>需要准备的环境</h2><p>两台 centos7 服务器</p><p>分别是 192.168.205.10，192.168.205.11 两个地址</p><p>服务器这块采用 <a href="https://baike.baidu.com/item/Vagrant/1321946?fr=aladdin" target="_blank" rel="noopener">vagrant</a> + Oracle VM VirtualBox 构建</p><p>这里给出用到的 Vagrantfile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># -*- mode: ruby -*-</span><br><span class="line"># vi: set ft=ruby :</span><br><span class="line"></span><br><span class="line">Vagrant.require_version &quot;&gt;= 1.6.0&quot;</span><br><span class="line"></span><br><span class="line">boxes = [</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; &quot;docker-node1&quot;,</span><br><span class="line">        :eth1 =&gt; &quot;192.168.205.10&quot;,</span><br><span class="line">        :mem =&gt; &quot;1024&quot;,</span><br><span class="line">        :cpu =&gt; &quot;1&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; &quot;docker-node2&quot;,</span><br><span class="line">        :eth1 =&gt; &quot;192.168.205.11&quot;,</span><br><span class="line">        :mem =&gt; &quot;1024&quot;,</span><br><span class="line">        :cpu =&gt; &quot;1&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Vagrant.configure(2) do |config|</span><br><span class="line"></span><br><span class="line">  config.vm.box = &quot;centos/7&quot;</span><br><span class="line"></span><br><span class="line">  boxes.each do |opts|</span><br><span class="line">      config.vm.define opts[:name] do |config|</span><br><span class="line">        config.vm.hostname = opts[:name]</span><br><span class="line">        config.vm.provider &quot;vmware_fusion&quot; do |v|</span><br><span class="line">          v.vmx[&quot;memsize&quot;] = opts[:mem]</span><br><span class="line">          v.vmx[&quot;numvcpus&quot;] = opts[:cpu]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]</span><br><span class="line">          v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]</span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">        config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line">      end</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">#  config.vm.synced_folder &quot;./labs&quot;, &quot;/home/vagrant/labs&quot;</span><br><span class="line">#  config.vm.provision &quot;shell&quot;, privileged: true, path: &quot;./setup.sh&quot;</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>不熟悉vagrant的朋友 可以直接使用 Oracle VM VirtualBox 或是其他的虚拟环境，比如docker，或是阿里云ECS环境</p><p>准备下篇文章 写一个 vagrant 入门教程==。==</p><h2 id="安装需要的依赖包"><a href="#安装需要的依赖包" class="headerlink" title="安装需要的依赖包"></a>安装需要的依赖包</h2><blockquote><p>$ yum -y install gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel open openssl-devel</p></blockquote><p>下面对 keepalived 和 nginx 的编译需要用到 gcc,因为 这两软件都是采用C语言编译的</p><h2 id="安装的文件都解压在这"><a href="#安装的文件都解压在这" class="headerlink" title="安装的文件都解压在这"></a>安装的文件都解压在这</h2><p><img src="/2019-03-28-Keepalived + Nginx + Tomcat 搭建高可用负载均衡架构/123.png" alt="123"></p><p>jdk的安装就不说了</p><h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><p>解压即可</p><h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><blockquote><p>（1）解压安装包：tar -zxvf nginx-1.12.2.tar.gz</p></blockquote><blockquote><p>（2）进入到nginx-1.12.2目录：cd nginx-1.12.2</p></blockquote><blockquote><p>（3）编译：</p></blockquote><blockquote><p>a) ./configure –with-http_stub_status_module –with-http_ssl_module  –prefix=/usr/local/nginx</p></blockquote><blockquote><p>b) sudo make &amp;&amp; sudo make install</p></blockquote><h2 id="安装Keepalived"><a href="#安装Keepalived" class="headerlink" title="安装Keepalived"></a>安装Keepalived</h2><blockquote><p>（1）解压安装包：tar -zxvf keepalived-1.3.9.tar.gz</p></blockquote><blockquote><p>（2）进入到keepalived-1.3.9目录：cd keepalived-1.3.9</p></blockquote><blockquote><p>（3）执行编译：</p></blockquote><blockquote><p>a）./configure –prefix=/usr/local/keepalived –sysconf=/etc</p></blockquote><blockquote><p>b）sudo make &amp;&amp; sudo make install</p></blockquote><h2 id="分别配置两台服务器的Nginx"><a href="#分别配置两台服务器的Nginx" class="headerlink" title="分别配置两台服务器的Nginx"></a>分别配置两台服务器的Nginx</h2><ol><li>分别修改两台服务器nginx配置文件，vi /usr/local/nginx/conf/nginx.conf</li><li>内容如下：<br>==ps:请仔细看下 里面的注释==<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#nginx进程数</span><br><span class="line">worker_processes  1;</span><br><span class="line"></span><br><span class="line">#单个进程最大连接数</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#http服务器配置</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">#长连接超时时间，单位是秒</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">#upstream负载均衡配置，配置路由到tomcat的服务地址以及权重</span><br><span class="line">    upstream localhost&#123;</span><br><span class="line">       # 这里是 上面准备的两台服务器的 ip及端口    </span><br><span class="line">       server 192.168.205.10:8080 weight=2;</span><br><span class="line">       server 192.168.205.11:8080 weight=2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#虚拟主机的配置</span><br><span class="line">    server &#123;</span><br><span class="line">    #监听端口</span><br><span class="line">        listen       80;</span><br><span class="line"> #域名可以有多个，用空格隔开</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">#nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">            proxy_connect_timeout 3;</span><br><span class="line">#后端服务器数据回传时间(代理发送超时)</span><br><span class="line">            proxy_send_timeout 30;</span><br><span class="line">#连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">            proxy_read_timeout 30;</span><br><span class="line">            proxy_pass http://localhost;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="主-Keepalived配置"><a href="#主-Keepalived配置" class="headerlink" title="==主==Keepalived配置"></a>==主==Keepalived配置</h2><ol><li>修改10服务器的keepalived配置文件，vi /etc/keepalived/keepalived.conf</li><li>内容如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">#全局配置</span><br><span class="line">global_defs &#123;</span><br><span class="line">   #keepalived切换的时候，发消息到指定的email，可配置多个email</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     854554762@qq.com</span><br><span class="line">   &#125;</span><br><span class="line">   #通知邮件从哪个地址发出</span><br><span class="line">   notification_email_from 854554762@qq.com</span><br><span class="line">   #通知邮件的smtp地址</span><br><span class="line">   smtp_server smtp.qq.com</span><br><span class="line">   #连接smtp服务器的超时时间，单位秒</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   #Keepalived的机器标识，一个网络内保持唯一</span><br><span class="line">   router_id nginx-master</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#执行脚本配置</span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">#脚本所在路径 下面会给出</span><br><span class="line">    script &quot;/home/project/keepalived/check_nginx.sh&quot;</span><br><span class="line">#脚本执行间隔时间，秒</span><br><span class="line">    interval 2</span><br><span class="line">#优先级</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line">#keepalived实例配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">#指定实例的初始状态，MASTER或BACKUP两种状态，并且需要大写</span><br><span class="line">    state MASTER</span><br><span class="line">#实例绑定的网卡 这个的网卡 请自行查询 自己机器的网卡 执行 ip a</span><br><span class="line">    interface eth0</span><br><span class="line">#虚拟路由标识，是一个数字，整个VRRP内唯一，如果keepalived配置了主备，需要相同</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">#优先级，数值愈大，优先级越高</span><br><span class="line">    priority 100</span><br><span class="line">#MASTER与BACKUP之间同步检查的时间间隔，单位为秒</span><br><span class="line">    advert_int 1</span><br><span class="line">#通信验证</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass feinik</span><br><span class="line">    &#125;</span><br><span class="line">#追踪外围脚本</span><br><span class="line">    track_script &#123;</span><br><span class="line">    #这里配置vrrp_script的名称</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">#虚拟ip配置，可配置多个</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.205.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="备-Keepalived配置"><a href="#备-Keepalived配置" class="headerlink" title="==备==Keepalived配置"></a>==备==Keepalived配置</h2><ol><li>修改11服务器的keepalived配置文件，vi /etc/keepalived/keepalived.conf</li><li>内容如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">! Configuration File for keepalived</span><br><span class="line">#全局配置</span><br><span class="line">global_defs &#123;</span><br><span class="line">   #keepalived切换的时候，发消息到指定的email，可配置多个email</span><br><span class="line">   notification_email &#123;</span><br><span class="line">     854554762@qq.com</span><br><span class="line">   &#125;</span><br><span class="line">   #通知邮件从哪个地址发出</span><br><span class="line">   notification_email_from 854554762@qq.com</span><br><span class="line">   #通知邮件的smtp地址</span><br><span class="line">   smtp_server smtp.qq.com</span><br><span class="line">   #连接smtp服务器的超时时间，单位秒</span><br><span class="line">   smtp_connect_timeout 30</span><br><span class="line">   #Keepalived的机器标识，一个网络内保持唯一</span><br><span class="line">   router_id nginx-master</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#执行脚本配置</span><br><span class="line">vrrp_script chk_nginx &#123;</span><br><span class="line">#脚本所在路径</span><br><span class="line">    script &quot;/home/project/keepalived/check_nginx.sh&quot;</span><br><span class="line">#脚本执行间隔时间，秒</span><br><span class="line">    interval 2</span><br><span class="line">#优先级</span><br><span class="line">    weight 2</span><br><span class="line">&#125;</span><br><span class="line">#keepalived实例配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">#指定实例的初始状态，MASTER或BACKUP两种状态，并且需要大写</span><br><span class="line">    state BACKUP</span><br><span class="line">#实例绑定的网卡 这个的网卡 请自行查询 自己机器的网卡 执行 ip a</span><br><span class="line">    interface eth0</span><br><span class="line">#虚拟路由标识，是一个数字，整个VRRP内唯一，如果keepalived配置了主备，需要相同</span><br><span class="line">    virtual_router_id 51</span><br><span class="line">#优先级，数值愈大，优先级越高</span><br><span class="line">    priority 99</span><br><span class="line">#MASTER与BACKUP之间同步检查的时间间隔，单位为秒</span><br><span class="line">    advert_int 1</span><br><span class="line">#通信验证</span><br><span class="line">    authentication &#123;</span><br><span class="line">        auth_type PASS</span><br><span class="line">        auth_pass feinik</span><br><span class="line">    &#125;</span><br><span class="line">#追踪外围脚本</span><br><span class="line">    track_script &#123;</span><br><span class="line">    #这里配置vrrp_script的名称</span><br><span class="line">        chk_nginx</span><br><span class="line">    &#125;</span><br><span class="line">#虚拟ip配置，可配置多个</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.205.200</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx状态检查脚本创建"><a href="#Nginx状态检查脚本创建" class="headerlink" title="Nginx状态检查脚本创建"></a>Nginx状态检查脚本创建</h2><ol><li>新建Nginx的状态检查脚本：check_nginx.sh</li><li>内容如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">NGINX=/usr/common/nginx/sbin/nginx</span><br><span class="line">PORT=80</span><br><span class="line">nmap localhost -p $PORT | grep &quot;$PORT/tcp open&quot;</span><br><span class="line">#echo $?</span><br><span class="line">if [ $? -ne 0 ];then</span><br><span class="line">    $NGINX -s stop</span><br><span class="line">    #这里再次尝试启动NG</span><br><span class="line">    $NGINX</span><br><span class="line">    sleep 5</span><br><span class="line">    nmap localhost -p $PORT | grep &quot;$PORT/tcp open&quot;</span><br><span class="line">    [ $? -ne 0 ] &amp;&amp; cd /usr/common/keepalived/sbin &amp;&amp; pkill keepalived</span><br><span class="line">    echo &quot;stoped&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="运行测试"><a href="#运行测试" class="headerlink" title="运行测试"></a>运行测试</h2><ol><li><p>为了更直观的查看到keepalived切换的效果，将10服务器中的nginx的upstream服务只配置10的tomcat服务地址，11服务器中的upstream服务只配置11的tomcat服务地址，这样只需要观察将10服务器中的nginx关闭看使用虚拟ip是否可以访问到11服务器的tomcat。</p></li><li><p>分别启动两个服务器中的tomcat、nginx、keepalived，访问虚拟ip：192.168.10.200，可以查看到访问的是主keepalived服务器的tomcat</p><blockquote><p>Tomcat 启动方式 bin 目录下执行 ./startup.sh<br>nginx 的启动方式 在nginx的安装目录(/usr/local/nginx)下 执行 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./nginx -c /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></blockquote></li></ol><blockquote><p>Kepalived 的安装目录(/usr/local/kepalived)下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./keepalived</span><br></pre></td></tr></table></figure></p></blockquote><p>以上操作完成 即可！</p><p><img src="/2019-03-28-Keepalived + Nginx + Tomcat 搭建高可用负载均衡架构/321.png" alt="321"></p><p>关闭11服务器的nginx，nginx -s stop，再次访问虚拟ip，如下：说明主keepalived通过配置的脚本检测到了本服务的nginx服务挂掉了，所以立马切换至了备的keepalived，这时10服务器的keepalived升为了主，所以就访问到了10服务器的tomcat。</p><p><img src="/2019-03-28-Keepalived + Nginx + Tomcat 搭建高可用负载均衡架构/456.png" alt="456"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;初期的互联网企业由于业务量较小，所以一般单机部署，实现单点访问即可满足业务的需求，这也是最简单的部署方式，但是随着
      
    
    </summary>
    
      <category term="高可用" scheme="https://puruis.github.io/categories/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
    
      <category term="Keepalived" scheme="https://puruis.github.io/tags/Keepalived/"/>
    
      <category term="Nginx" scheme="https://puruis.github.io/tags/Nginx/"/>
    
      <category term="Tomcat" scheme="https://puruis.github.io/tags/Tomcat/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简单入门-Dockderfile基础语法</title>
    <link href="https://puruis.github.io/2019-03-26-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%885%EF%BC%89/"/>
    <id>https://puruis.github.io/2019-03-26-docker 简单入门（5）/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-26T11:25:20.418Z</updated>
    
    <content type="html"><![CDATA[<p>还是话不多说，直接开始</p><p>我们先说说 Dockerfile的语法</p><hr><p>1.每个Dockerfile必须以FROM指令开头，FROM指明了当前镜像创建的基镜像，也就是说每个镜像必须基于一个已存在的镜像进行创建。FROM指令后直接跟基镜像的名称或者镜像名称加标签。镜像的名称和标签可以去Docker Hub或者使用命令docker search keyword 进行搜索。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;案例：</span><br><span class="line">&gt;     1.FROM scratch 表示不指定具体镜像使用空镜像作为基础镜像。</span><br><span class="line">&gt;     2.FROM centos #使用centos做为基础镜像</span><br><span class="line">&gt;     3.FROM ubuntu:14.00 #指定具体版本</span><br></pre></td></tr></table></figure></p><p><u>ps： 为了安全 应尽量使用官方 image 作为基础镜像</u></p><hr><p>2.LABEL 关键字 标签？ 看案例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    1.LABEL maintainer=“purui@qq.com”</span><br><span class="line">&gt;    2.LABEL version=&quot;1.0.0&quot;</span><br><span class="line">&gt;    3.LABEL description=&quot;描述&quot;</span><br></pre></td></tr></table></figure></p><hr><p>3.RUN 关键字 运行命令 RUN命令有两种格式<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&gt;    1.RUN yum update &amp;&amp; yum install -y vim</span><br><span class="line">&gt;    2.RUN [&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;echo hello&quot;]</span><br><span class="line">   ``` </span><br><span class="line">&lt;u&gt;ps:注意：多行命令不要写多个RUN，原因是Dockerfile中每一个指令都会建立一层.</span><br><span class="line"></span><br><span class="line"> 多少个RUN就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。</span><br><span class="line"></span><br><span class="line">RUN书写时的换行符是\&lt;/u&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">4.WORKDIR 关键字 可以设定当前的工作目录</span><br><span class="line">&gt;    1.WORKDIR /root #如果没有 root目录会自动创建</span><br><span class="line">    </span><br><span class="line"> &lt;u&gt;ps:不推荐使用 RUN cd 推荐使用绝对目录&lt;/u&gt;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">5.ADD关键字 可以从宿主机copy 文件到image中，如果是压缩文件还会自动解压</span><br><span class="line">&gt;    1.ADD hello.sh / #copy hello.sh 到 根目录下</span><br><span class="line">&gt;    2.如果先使用 WORKDIR /root 指定目录，再运行 ADD hello.sh /test #会copy到 /root/test/下面</span><br><span class="line">    </span><br><span class="line">6.ENV 关键字 声明常量</span><br></pre></td></tr></table></figure></p><blockquote><p>   语法有两种</p><ol><li>ENV <key> <value></value></key></li><li>ENV <key>=<value> …<br>3.ENV MYSQL_VERSION 5.6<br>RUN apt-get install mysql-server=”${MYSQL_VERSION}”<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">7.CMD 命令为运行容器执行默认的命令，如果有多个命令那么它只执行最后一个</span><br><span class="line"></span><br><span class="line">语法有三种写法</span><br></pre></td></tr></table></figure></value></key></li></ol></blockquote><blockquote><ol><li>CMD [“executable”,”param1”,”param2”]</li><li>CMD [“param1”,”param2”]</li><li>CMD command param1 param2<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">8.RUN &amp; CMD</span><br><span class="line"></span><br><span class="line">&gt;不要把RUN和CMD搞混了。</span><br><span class="line">&gt;</span><br><span class="line">&gt;RUN是构件容器时就运行的命令以及提交运行结果</span><br><span class="line">&gt;</span><br><span class="line">&gt;CMD是容器启动时执行的命令，在构件时并不运行，构件时紧紧指定了这个命令到底是个什么样子</span><br><span class="line"></span><br><span class="line">9.EXPOSE 可以暴露容器内部的应用端口 给宿主机访问</span><br><span class="line">      </span><br><span class="line">10.ENTRYPOINT 功能是启动时的默认命令</span><br><span class="line"></span><br><span class="line">&gt;与CMD比较说明（这俩命令太像了，而且还可以配合使用）：</span><br><span class="line">&gt;</span><br><span class="line">&gt;1. 相同点：</span><br><span class="line">&gt;</span><br><span class="line">&gt;只能写一条，如果写了多条，那么只有最后一条生效</span><br><span class="line">&gt;</span><br><span class="line">&gt;容器启动时才运行，运行时机相同</span><br><span class="line">&gt;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br><span class="line">&gt;2. 不同点：</span><br><span class="line">&gt;</span><br><span class="line">&gt; ENTRYPOINT不会被运行的command覆盖，而CMD则会被覆盖</span><br><span class="line">&gt;</span><br><span class="line">&gt; 如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数</span><br><span class="line">&gt; 如下：</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>FROM ubuntu<br>ENTRYPOINT [“top”, “-b”]<br>CMD [“-c”]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果我们在Dockerfile种同时写了ENTRYPOINT和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效</span><br><span class="line"></span><br><span class="line">如下：</span><br></pre></td></tr></table></figure></p><p>FROM ubuntu<br>ENTRYPOINT [“top”, “-b”]<br>CMD ls -al<br><code>`</code><br>那么将执行ls -al ,top -b不会执行。<br>这是docker 官方给出的 组合执行情况<br><img src="/2019-03-26-docker 简单入门（5）/9C7EDE9A-0F54-449B-BE72-73D73984AA5D.jpg" alt="ad2d70f43e9135378d13b9af5ad9beb8"></p><p>#参考<br><a href="https://www.cnblogs.com/dazhoushuoceshi/p/7066041.html" target="_blank" rel="noopener">https://www.cnblogs.com/dazhoushuoceshi/p/7066041.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是话不多说，直接开始&lt;/p&gt;
&lt;p&gt;我们先说说 Dockerfile的语法&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;1.每个Dockerfile必须以FROM指令开头，FROM指明了当前镜像创建的基镜像，也就是说每个镜像必须基于一个已存在的镜像进行创建。FROM指令后直接跟基镜像的名称或
      
    
    </summary>
    
      <category term="Docker" scheme="https://puruis.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://puruis.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="https://puruis.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Dockderfile" scheme="https://puruis.github.io/tags/Dockderfile/"/>
    
  </entry>
  
  <entry>
    <title>实现自己的维基百科-Elasticsearch</title>
    <link href="https://puruis.github.io/2019-03-26-Elasticsearch/"/>
    <id>https://puruis.github.io/2019-03-26-Elasticsearch/</id>
    <published>2019-03-25T16:00:00.000Z</published>
    <updated>2019-03-26T02:12:24.793Z</updated>
    
    <content type="html"><![CDATA[<p>全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。</p><p>它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。</p><p>Elastic 的底层是开源库 Lucene。但是，你没法直接用 Lucene，必须自己写代码去调用它的接口。Elastic 是 Lucene 的封装，提供了 REST API 的操作接口，开箱即用。</p><p>本文从零开始，讲解如何使用 Elastic 搭建自己的全文搜索引擎。每一步都有详细的说明，大家跟着做就能学会。</p><p>一、安装<br>Elastic 需要 Java 8 环境。如果你的机器还没安装 Java，可以参考这篇文章，注意要保证环境变量JAVA_HOME正确设置。</p><p>安装完 Java，就可以跟着官方文档安装 Elastic。直接下载压缩包比较简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.zip</span><br><span class="line"><span class="meta">$</span> unzip elasticsearch-5.5.1.zip</span><br><span class="line"><span class="meta">$</span> cd elasticsearch-5.5.1/</span><br></pre></td></tr></table></figure><p>接着，进入解压后的目录，运行下面的命令，启动 Elastic。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./bin/elasticsearch</span><br></pre></td></tr></table></figure><p>如果这时报错”max virtual memory areas vm.maxmapcount [65530] is too low”，要运行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo sysctl -w vm.max_map_count=262144</span><br></pre></td></tr></table></figure><p>如果一切正常，Elastic 就会在默认的9200端口运行。这时，打开另一个命令行窗口，请求该端口，会得到说明信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl localhost:9200</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "name" : "atntrTf",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "tf9250XhQ6ee4h7YI11anA",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "5.5.1",</span><br><span class="line">    "build_hash" : "19c13d0",</span><br><span class="line">    "build_date" : "2017-07-18T20:44:24.823Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "6.6.0"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，请求9200端口，Elastic 返回一个 JSON 对象，包含当前节点、集群、版本等信息。</p><p>按下 Ctrl + C，Elastic 就会停止运行。</p><p>默认情况下，Elastic 只允许本机访问，如果需要远程访问，可以修改 Elastic 安装目录的config/elasticsearch.yml文件，去掉network.host的注释，将它的值改成0.0.0.0，然后重新启动 Elastic。</p><p>network.host: 0.0.0.0<br>上面代码中，设成0.0.0.0让任何人都可以访问。线上服务不要这样设置，要设成具体的 IP。</p><p>二、基本概念<br>2.1 Node 与 Cluster<br>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</p><p>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</p><p>2.2 Index<br>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</p><p>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</p><p>下面的命令可以查看当前节点的所有 Index。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X GET 'http://localhost:9200/_cat/indices?v'</span><br></pre></td></tr></table></figure><p>2.3 Document<br>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</p><p>Document 使用 JSON 格式表示，下面是一个例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "user": "张三",</span><br><span class="line">  "title": "工程师",</span><br><span class="line">  "desc": "数据库管理"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p><p>2.4 Type<br>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</p><p>不同的 Type 应该有相似的结构（schema），举例来说，id字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如products和logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。</p><p>下面的命令可以列出每个 Index 所包含的 Type。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/_mapping?pretty=true'</span><br></pre></td></tr></table></figure><p>根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。</p><p>三、新建和删除 Index<br>新建 Index，可以直接向 Elastic 服务器发出 PUT 请求。下面的例子是新建一个名叫weather的 Index。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X PUT 'localhost:9200/weather'</span><br></pre></td></tr></table></figure><p>服务器返回一个 JSON 对象，里面的acknowledged字段表示操作成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "acknowledged":true,</span><br><span class="line">  "shards_acknowledged":true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们发出 DELETE 请求，删除这个 Index。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X DELETE 'localhost:9200/weather'</span><br></pre></td></tr></table></figure><p>四、中文分词设置<br>首先，安装中文分词插件。这里使用的是 ik，也可以考虑其他插件（比如 smartcn）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> ./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip</span><br></pre></td></tr></table></figure><p>上面代码安装的是5.5.1版的插件，与 Elastic 5.5.1 配合使用。</p><p>接着，重新启动 Elastic，就会自动加载这个新安装的插件。</p><p>然后，新建一个 Index，指定需要分词的字段。这一步根据数据结构而异，下面的命令只针对本文。基本上，凡是需要搜索的中文字段，都要单独设置一下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X PUT 'localhost:9200/accounts' -d '</span><br><span class="line">&#123;</span><br><span class="line">  "mappings": &#123;</span><br><span class="line">    "person": &#123;</span><br><span class="line">      "properties": &#123;</span><br><span class="line">        "user": &#123;</span><br><span class="line">          "type": "text",</span><br><span class="line">          "analyzer": "ik_max_word",</span><br><span class="line">          "search_analyzer": "ik_max_word"</span><br><span class="line">        &#125;,</span><br><span class="line">        "title": &#123;</span><br><span class="line">          "type": "text",</span><br><span class="line">          "analyzer": "ik_max_word",</span><br><span class="line">          "search_analyzer": "ik_max_word"</span><br><span class="line">        &#125;,</span><br><span class="line">        "desc": &#123;</span><br><span class="line">          "type": "text",</span><br><span class="line">          "analyzer": "ik_max_word",</span><br><span class="line">          "search_analyzer": "ik_max_word"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码中，首先新建一个名称为accounts的 Index，里面有一个名称为person的 Type。person有三个字段。</p><p>user<br>title<br>desc<br>这三个字段都是中文，而且类型都是文本（text），所以需要指定中文分词器，不能使用默认的英文分词器。</p><p>Elastic 的分词器称为 analyzer。我们对每个字段指定分词器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"user": &#123;</span><br><span class="line">  "type": "text",</span><br><span class="line">  "analyzer": "ik_max_word",</span><br><span class="line">  "search_analyzer": "ik_max_word"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，analyzer是字段文本的分词器，search_analyzer是搜索词的分词器。ik_max_word分词器是插件ik提供的，可以对文本进行最大数量的分词。</p><p>五、数据操作<br>5.1 新增记录<br>向指定的 /Index/Type 发送 PUT 请求，就可以在 Index 里面新增一条记录。比如，向/accounts/person发送请求，就可以新增一条人员记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X PUT 'localhost:9200/accounts/person/1' -d '</span><br><span class="line">&#123;</span><br><span class="line">  "user": "张三",</span><br><span class="line">  "title": "工程师",</span><br><span class="line">  "desc": "数据库管理"</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>服务器返回的 JSON 对象，会给出 Index、Type、Id、Version 等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index":"accounts",</span><br><span class="line">  "_type":"person",</span><br><span class="line">  "_id":"1",</span><br><span class="line">  "_version":1,</span><br><span class="line">  "result":"created",</span><br><span class="line">  "_shards":&#123;"total":2,"successful":1,"failed":0&#125;,</span><br><span class="line">  "created":true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你仔细看，会发现请求路径是/accounts/person/1，最后的1是该条记录的 Id。它不一定是数字，任意字符串（比如abc）都可以。</p><p>新增记录的时候，也可以不指定 Id，这时要改成 POST 请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X POST 'localhost:9200/accounts/person' -d '</span><br><span class="line">&#123;</span><br><span class="line">  "user": "李四",</span><br><span class="line">  "title": "工程师",</span><br><span class="line">  "desc": "系统管理"</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码中，向/accounts/person发出一个 POST 请求，添加一个记录。这时，服务器返回的 JSON 对象里面，_id字段就是一个随机字符串。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index":"accounts",</span><br><span class="line">  "_type":"person",</span><br><span class="line">  "_id":"AV3qGfrC6jMbsbXb6k1p",</span><br><span class="line">  "_version":1,</span><br><span class="line">  "result":"created",</span><br><span class="line">  "_shards":&#123;"total":2,"successful":1,"failed":0&#125;,</span><br><span class="line">  "created":true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果没有先创建 Index（这个例子是accounts），直接执行上面的命令，Elastic 也不会报错，而是直接生成指定的 Index。所以，打字的时候要小心，不要写错 Index 的名称。</p><p>5.2 查看记录<br>向/Index/Type/Id发出 GET 请求，就可以查看这条记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/1?pretty=true'</span><br></pre></td></tr></table></figure><p>上面代码请求查看/accounts/person/1这条记录，URL 的参数pretty=true表示以易读的格式返回。</p><p>返回的数据中，found字段表示查询成功，_source字段返回原始记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "_index" : "accounts",</span><br><span class="line">  "_type" : "person",</span><br><span class="line">  "_id" : "1",</span><br><span class="line">  "_version" : 1,</span><br><span class="line">  "found" : true,</span><br><span class="line">  "_source" : &#123;</span><br><span class="line">    "user" : "张三",</span><br><span class="line">    "title" : "工程师",</span><br><span class="line">    "desc" : "数据库管理"</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 Id 不正确，就查不到数据，found字段就是false。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/weather/beijing/abc?pretty=true'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index" : "accounts",</span><br><span class="line">  "_type" : "person",</span><br><span class="line">  "_id" : "abc",</span><br><span class="line">  "found" : false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.3 删除记录<br>删除记录就是发出 DELETE 请求。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X DELETE 'localhost:9200/accounts/person/1'</span><br></pre></td></tr></table></figure><p>这里先不要删除这条记录，后面还要用到。</p><p>5.4 更新记录<br>更新记录就是使用 PUT 请求，重新发送一次数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl -X PUT 'localhost:9200/accounts/person/1' -d '</span><br><span class="line">&#123;</span><br><span class="line">    "user" : "张三",</span><br><span class="line">    "title" : "工程师",</span><br><span class="line">    "desc" : "数据库管理，软件开发"</span><br><span class="line">&#125;' </span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "_index":"accounts",</span><br><span class="line">  "_type":"person",</span><br><span class="line">  "_id":"1",</span><br><span class="line">  "_version":2,</span><br><span class="line">  "result":"updated",</span><br><span class="line">  "_shards":&#123;"total":2,"successful":1,"failed":0&#125;,</span><br><span class="line">  "created":false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，我们将原始数据从”数据库管理”改成”数据库管理，软件开发”。 返回结果里面，有几个字段发生了变化。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"_version" : 2,</span><br><span class="line">"result" : "updated",</span><br><span class="line">"created" : false</span><br></pre></td></tr></table></figure><p>可以看到，记录的 Id 没变，但是版本（version）从1变成2，操作类型（result）从created变成updated，created字段变成false，因为这次不是新建记录。</p><p>六、数据查询<br>6.1 返回所有记录<br>使用 GET 方法，直接请求/Index/Type/_search，就会返回所有记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "took":2,</span><br><span class="line">  "timed_out":false,</span><br><span class="line">  "_shards":&#123;"total":5,"successful":5,"failed":0&#125;,</span><br><span class="line">  "hits":&#123;</span><br><span class="line">    "total":2,</span><br><span class="line">    "max_score":1.0,</span><br><span class="line">    "hits":[</span><br><span class="line">      &#123;</span><br><span class="line">        "_index":"accounts",</span><br><span class="line">        "_type":"person",</span><br><span class="line">        "_id":"AV3qGfrC6jMbsbXb6k1p",</span><br><span class="line">        "_score":1.0,</span><br><span class="line">        "_source": &#123;</span><br><span class="line">          "user": "李四",</span><br><span class="line">          "title": "工程师",</span><br><span class="line">          "desc": "系统管理"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        "_index":"accounts",</span><br><span class="line">        "_type":"person",</span><br><span class="line">        "_id":"1",</span><br><span class="line">        "_score":1.0,</span><br><span class="line">        "_source": &#123;</span><br><span class="line">          "user" : "张三",</span><br><span class="line">          "title" : "工程师",</span><br><span class="line">          "desc" : "数据库管理，软件开发"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，返回结果的 took字段表示该操作的耗时（单位为毫秒），timed_out字段表示是否超时，hits字段表示命中的记录，里面子字段的含义如下。</p><p>total：返回记录数，本例是2条。<br>max_score：最高的匹配程度，本例是1.0。<br>hits：返回的记录组成的数组。<br>返回的记录中，每条记录都有一个_score字段，表示匹配的程序，默认是按照这个字段降序排列。</p><p>6.2 全文搜索<br>Elastic 的查询非常特别，使用自己的查询语法，要求 GET 请求带有数据体。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'  -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query" : &#123; "match" : &#123; "desc" : "软件" &#125;&#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码使用 Match 查询，指定的匹配条件是desc字段里面包含”软件”这个词。返回结果如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "took":3,</span><br><span class="line">  "timed_out":false,</span><br><span class="line">  "_shards":&#123;"total":5,"successful":5,"failed":0&#125;,</span><br><span class="line">  "hits":&#123;</span><br><span class="line">    "total":1,</span><br><span class="line">    "max_score":0.28582606,</span><br><span class="line">    "hits":[</span><br><span class="line">      &#123;</span><br><span class="line">        "_index":"accounts",</span><br><span class="line">        "_type":"person",</span><br><span class="line">        "_id":"1",</span><br><span class="line">        "_score":0.28582606,</span><br><span class="line">        "_source": &#123;</span><br><span class="line">          "user" : "张三",</span><br><span class="line">          "title" : "工程师",</span><br><span class="line">          "desc" : "数据库管理，软件开发"</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Elastic 默认一次返回10条结果，可以通过size字段改变这个设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'  -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;,</span><br><span class="line">  "size": 1</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码指定，每次只返回一条结果。</p><p>还可以通过from字段，指定位移。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'  -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query" : &#123; "match" : &#123; "desc" : "管理" &#125;&#125;,</span><br><span class="line">  "from": 1,</span><br><span class="line">  "size": 1</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码指定，从位置1开始（默认是从位置0开始），只返回一条结果。</p><p>6.3 逻辑运算<br>如果有多个搜索关键字， Elastic 认为它们是or关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'  -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query" : &#123; "match" : &#123; "desc" : "软件 系统" &#125;&#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>上面代码搜索的是软件 or 系统。</p><p>如果要执行多个关键词的and搜索，必须使用布尔查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> curl 'localhost:9200/accounts/person/_search'  -d '</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": [</span><br><span class="line">        &#123; "match": &#123; "desc": "软件" &#125; &#125;,</span><br><span class="line">        &#123; "match": &#123; "desc": "系统" &#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure><p>七、参考链接<br>ElasticSearch 官方手册<br>A Practical Introduction to Elasticsearch</p><h1 id="转载-自-http-www-ruanyifeng-com-blog-2017-08-elasticsearch-html"><a href="#转载-自-http-www-ruanyifeng-com-blog-2017-08-elasticsearch-html" class="headerlink" title="转载 自 http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html"></a>转载 自 <a href="http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html</a></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;全文搜索属于最常见的需求，开源的 Elasticsearch （以下简称 Elastic）是目前全文搜索引擎的首选。&lt;/p&gt;
&lt;p&gt;它可以快速地储存、搜索和分析海量数据。维基百科、Stack Overflow、Github 都采用它。&lt;/p&gt;
&lt;p&gt;Elastic 的底层是
      
    
    </summary>
    
      <category term="Elasticsearch" scheme="https://puruis.github.io/categories/Elasticsearch/"/>
    
    
      <category term="Elasticsearch" scheme="https://puruis.github.io/tags/Elasticsearch/"/>
    
      <category term="搜索" scheme="https://puruis.github.io/tags/%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>docker 简单入门-初识Container</title>
    <link href="https://puruis.github.io/2019-03-25-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%884%EF%BC%89/"/>
    <id>https://puruis.github.io/2019-03-25-docker 简单入门（4）/</id>
    <published>2019-03-24T16:00:00.000Z</published>
    <updated>2019-03-26T11:24:56.122Z</updated>
    
    <content type="html"><![CDATA[<p>话不多说半句多，直接上。<br>什么是Container ？</p><ol><li>container是通过image创建</li><li>container的本质是在image（image本身不可读写）的最上层建立了一个layer（可读写的），这个和Java中类与实例的关系比较像</li><li>image负责存储和分发，container负责运行app</li></ol><p><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.37.03.png" alt="25f06b6df9519bbfbcda00bd46cd185f"></p><p>我们来用image 来创建一个 container<br>运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure></p><p><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.40.51.png" alt="c88262104eb28e30468ed99e64664417"><br>因为我本地没有 hello-world这个镜像所以 它回去 dockerhub 上拉取官方的镜像，我们能看到它打印出了 hello from docker<br>然后我们运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure></p><p>看第二张图，我们发现 运行完成后没有然后运行记录，这是因为 它已经运行完了，自动退出了，<br>然后我们运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br></pre></td></tr></table></figure></p><p>就能看到 它已经退出三分钟了。<br><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.44.31.png" alt="3f34565bc628b62c2c4f71364022af70"></p><p>那么有什么办法 让它不停止运行吗？</p><p>答案是 有的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure></p><p>ps:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -d ubuntu</span><br></pre></td></tr></table></figure></p><p>-d 参数可以 让程序以 后台方式运行<br>这里 -it的意思 是 以交互式运行的方式 去运行这个镜像。<br>运行完毕后我们发现 我们进入了 ubuntu容器内部。ps:输入exit 回车 退出容器<br><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.49.29.png" alt="104a8c361aaa58a479cbf4a54fe21b80"></p><p>大家可以执行,查看详细的命令说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --help</span><br></pre></td></tr></table></figure></p><p><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.52.52.png" alt="983eb8123fb31d888d0bc008099f74e6"></p><p>然后我们输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a（查询所有）</span><br></pre></td></tr></table></figure></p><p>可以看到 之前我运行过的容器的历史<br>那么 我们怎么把它删除掉呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm(rmi 删除image rm默认删除容器) xxx（容器id）</span><br></pre></td></tr></table></figure></p><p>但是，这样只能一个个删除，有没有简单的方式呢？<br>程序员当然用代码解决<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls qa</span><br></pre></td></tr></table></figure></p><p>会查询出所有容器的 id<br>然后我门运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker container ls -qa)</span><br><span class="line">就能一次性删除所有的 容器了</span><br></pre></td></tr></table></figure></p><p><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午10.57.17.png" alt="947b4bd346cecf534ea579bf097d8821"></p><p>那么我还有个问题，这样一下子把所有容器都删除了，万一我不想删除所有 只想删除其中几个呢？<br>也是有办法的，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -f &quot;status=exited&quot;</span><br></pre></td></tr></table></figure></p><p>查询出所有已经退出的容器 通过 -f 参数过滤<br>然后加上 -qa 参数 可以查询出 所有退出容器的id<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -f &quot;status=exited&quot; -qa</span><br></pre></td></tr></table></figure></p><p>运行下面的命令 即可按照条件删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm $(docker container ls -f &quot;status=exited&quot; -qa)</span><br></pre></td></tr></table></figure></p><p><img src="/2019-03-25-docker 简单入门（4）/屏幕快照 2019-03-24 下午11.09.52.png" alt="0156e857efc47f97692110788e814a9d"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;话不多说半句多，直接上。&lt;br&gt;什么是Container ？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;container是通过image创建&lt;/li&gt;
&lt;li&gt;container的本质是在image（image本身不可读写）的最上层建立了一个layer（可读写的），这个和Java中类与实
      
    
    </summary>
    
      <category term="Docker" scheme="https://puruis.github.io/categories/Docker/"/>
    
    
      <category term="container" scheme="https://puruis.github.io/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>docker 简单入门-image</title>
    <link href="https://puruis.github.io/2019-03-22-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%883%EF%BC%89/"/>
    <id>https://puruis.github.io/2019-03-22-docker 简单入门（3）/</id>
    <published>2019-03-21T16:00:00.000Z</published>
    <updated>2019-03-26T11:24:49.421Z</updated>
    
    <content type="html"><![CDATA[<p>什么是 image？</p><p>1.文件和metaData的集合（root fileSystem）<br>2.并且它是分层的，每一层都可以添加或删除文件，成为一个新的image<br>3.不同的image 可以共享同一个layer（分层）<br>4.image本身是只读的</p><p>image是运行于 Linux Kernel（bootfs）之上的<br><img src="/2019-03-22-docker 简单入门（3）/屏幕快照 2019-03-21 下午10.58.43.png" alt="3b5782dfd8329c2a0a7e188eeb4a6e2f"></p><p>这里简单说下 docker 的image（镜像），在<a href="https://puruis.github.io/2019-03-16-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/">第一篇文章</a>的结尾 我们试着使用 docker pull hello-world 来拉取docker hub 的image，这个和 git的思路差不多，<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a><br>这里 我们简单看 images 和 Docker Register 的关系即可，</p><p>我们可以把Docker register想象成 github<br>images 想象成 我们开发本地的 git仓库<br>docker pull mysql 就是 通过 git 从github上拉取一个项目。 这样 我们就能理解了 docker 的image 和 register的关系，<br>不同的是 我们通过 git拉取的是一个个项目<br>docker pull 拉取的是 一个个镜像<br><img src="/2019-03-22-docker 简单入门（3）/屏幕快照 2019-03-19 下午7.13.07.png" alt="d59d09be7f02911661797e8d883a7b7b"><br>我们 通过 docker pull mysql<br>简单拉取一个 mysql<br><img src="/2019-03-22-docker 简单入门（3）/屏幕快照 2019-03-19 下午7.20.52.png" alt="b75a81732ddc6c9c07ac07f47e797f3b"></p><p>然后运行 docker image ls<br>就可以看到 我们刚刚拉取的 mysql 镜像 还有一些centos的镜像.<br><img src="/2019-03-22-docker 简单入门（3）/屏幕快照 2019-03-19 下午7.22.48.png" alt="aabeef1c5fb6b86ae292bccb3e88bc36"></p><p>image 的获取有 两种方式</p><p>1.去 build    Dockerfile文件获取<br>参考命令：    docker build -t xxx/sss .<br>2.或 register pull   <a href="https://hub.docker.com/search/?q=&amp;type=image" target="_blank" rel="noopener">dockerHub</a><br>参考命令：docker pull mysql</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;什么是 image？&lt;/p&gt;
&lt;p&gt;1.文件和metaData的集合（root fileSystem）&lt;br&gt;2.并且它是分层的，每一层都可以添加或删除文件，成为一个新的image&lt;br&gt;3.不同的image 可以共享同一个layer（分层）&lt;br&gt;4.image本身是只读
      
    
    </summary>
    
      <category term="Docker" scheme="https://puruis.github.io/categories/Docker/"/>
    
    
      <category term="image" scheme="https://puruis.github.io/tags/image/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简单入门-Docker-machine</title>
    <link href="https://puruis.github.io/2019-03-19-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%882%EF%BC%89/"/>
    <id>https://puruis.github.io/2019-03-19-docker 简单入门（2）/</id>
    <published>2019-03-18T16:00:00.000Z</published>
    <updated>2019-03-19T03:25:51.831Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们可以先从 docker的文档来了解下什么是 Docker-machine，<br>大概意思如下</p><p>您可以使用Docker Machine：</p><pre><code>1.在Mac或Windows上安装并运行Docker2.配置和管理多个远程Docker主机3.提供Swarm集群</code></pre><blockquote><p>Docker Machine是一个工具，可让您在虚拟主机上安装Docker Engine，并使用docker-machine命令管理主机。您可以使用Machine在本地Mac或Windows机器上，公司网络上，数据中心或Azure，AWS或Digital Ocean等云提供商上创建Docker主机。</p></blockquote><p><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-18 下午6.33.46.png" alt="ad2d70f43e9135378d13b9af5ad9beb8"></p><p>我们安装了 Docker 后 它默认 也安装了 Docker-machine</p><p><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-18 下午6.42.58.png" alt="a940583012c16853a2f82e16fb875b84"></p><p>来试下 用Docker-machine 在虚拟机上安装Docker</p><p>在Docker 启动的情况下 执行 docker-machine create –driver virtualbox default<br>它会自动开始下载 一个轻量级Linux发行版本（boot2docker）<br>成功之后 我们会在 VirtualBox 中发现有一个新的虚拟机正在运行中<br><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-18 下午8.40.06.png" alt="612cab248d48e3726d067d44799e8f2b"></p><p>然后执行 docker-machine ls<br>可以看到正在运行的实例，那么进入到 容器内部呢？<br>和vagrant差不多 docker-machine ssh default（容器名）<br><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-19 上午10.48.14.png" alt="1267c4daaf1c01ec60fcb916b1b89033"></p><p>运行。docker version 就会发现 这里已经装好了 docker<br><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-19 上午10.49.55.png" alt="cbe9ad15aed232ae447c60992072fae9"></p><p>其实 docker-machine 也可以用来创建云主机，有兴趣的朋友的自己尝试一下，可以参考下面的文档<br><img src="/2019-03-19-docker 简单入门（2）/屏幕快照 2019-03-19 上午10.51.44.png" alt="ee095e7a4802aea49262f9986a177942"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们可以先从 docker的文档来了解下什么是 Docker-machine，&lt;br&gt;大概意思如下&lt;/p&gt;
&lt;p&gt;您可以使用Docker Machine：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1.在Mac或Windows上安装并运行Docker
2.配置和管理多个远程Dock
      
    
    </summary>
    
      <category term="Docker" scheme="https://puruis.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://puruis.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="https://puruis.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
      <category term="Docker-machine" scheme="https://puruis.github.io/tags/Docker-machine/"/>
    
  </entry>
  
  <entry>
    <title>Docker 简单入门-安装Docker</title>
    <link href="https://puruis.github.io/2019-03-16-docker%20%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%EF%BC%881%EF%BC%89/"/>
    <id>https://puruis.github.io/2019-03-16-docker 简单入门（1）/</id>
    <published>2019-03-15T16:00:00.000Z</published>
    <updated>2019-03-26T11:24:34.363Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019-03-16-docker 简单入门（1）/7D2913DC-BF91-41C5-8DBE-5DA4CDA001D8.png" alt="logo"></p><p> 最近在整理docker的相关知识体系，顺便做些笔记和大家分享下，如果对docker有过一些了解的人，都知道docker是一门容器技术，并且在国内有不在少数的公司在使用，其实就包括了BAT,所以想了解前沿技术的朋友们也可以看看，这篇文章开始将带大家一起来学习了解 Docker</p><p>首先我们先来了解下什么 是 docker </p><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口</p></blockquote><p>传统的VM 如左图 最底层 需要一台服务器，之上安装了OS，然后之上 使用 Hypervisor 虚拟技术 在虚拟层之上 虚拟出系统在安装部署我们的应用，每个Guest Os 虚拟分配物理主机的空间，它们共享着主机的硬件资源，需要非常大空间和资源，所以我们可以把它看作是一个 硬件级别的虚拟化。</p><p>右图是docker 的架构<br>Docker 的容器利用LXC（Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。）<br>它是一个系统级别的虚拟化，而不是创建一个完成成熟的虚拟环境，所以它启动只需要几秒。</p><p>这里我们只是简单从一个方面来分析来 他们之间的差别，更多就不在这里详述了。<br><img src="/2019-03-16-docker 简单入门（1）/78A7A17E-858E-4C14-AA9B-D474681167FF.jpg" alt="logo"></p><p>首先我们来看看 Docker的安装<br>我们打开 <a href="https://docs.docker.com" target="_blank" rel="noopener">Docker文档中心</a></p><p><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午4.54.20.png" alt="logo"></p><p>然后我们可以看到左中的位置 有个 Get Docker 我们点开 选择Docker CE Docker的社区版 接下来 就是 选择我们 当前电脑的系统 这里<strong><u>注意 如果你的电脑是 windows 那么Docker 只支持Windows 10的版本</u></strong><br>win7 win8 等可以通过docker toolbox来安装 这里就不叙述了</p><p>然后我们看到右边出现下载链接 直接点击下载即可</p><p>操作步骤 一路next</p><p>我本地是 Mac系统 安装完成后 点击安装好的 软件 图标<br>稍等 ，右上角就会出现我们的 Docker 图标<br><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午4.57.57.png" alt="logo"></p><p>好了，接下来我们来验证下 我们是否已经安装成功了</p><p>在命令行界面 我们来验证下 是否安装成功，如果你能看到这个界面 证明你已经安装成功了。</p><p><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午5.01.22.png" alt="logo"></p><p>windows 的安装 同上 一路next 没有太大差别</p><p>主要我们说下 Linux的Docker安装， 这里我们通过 虚拟机来演示，我这里准备了一个 VirtualBox 然后 我们通过 vagrant 来安装 虚拟机，它可以帮助我们自动化安装一个虚拟机环境，并管理这个环境，我们先下载一个 <a href="https://www.vagrantup.com" target="_blank" rel="noopener">Vagrant</a> 也是一键安装，然后<br>输入 命令vagrant 验证vagrant -version 验证是否安装成功<br>如果你看到 如下界面 那就证明 你已经安装成功了<br><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午5.33.50.png" alt="logo"></p><p>接下来 我们建一个 centos7的 目录<br>然后 cd 切换到 centos7 下，运行 vagrant init centos/7 运行完 我们发现目录下 多了一个Vagrantfile 的文件<br><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午5.44.01.png" alt="logo"></p><p>然后 我们 运行 vagrant up 它就会自动去下载 centos7的 虚拟机镜像并安装 运行 这个过程可以会比较长<br>等安装完成后,我们可以看到 VirtualBox 中的虚拟机已经启动出来了<br><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午5.53.44.png" alt="logo"></p><p>查看 Docker 的 linux系统 的安装文档<br>1.先移除 之前安装的 docker<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line">```                  </span><br><span class="line">                  </span><br><span class="line">2.安装需要的一些包</span><br></pre></td></tr></table></figure></p><p>$ sudo yum install -y yum-utils \<br>  device-mapper-persistent-data \<br>  lvm2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">3.设置 远程库</span><br></pre></td></tr></table></figure></p><p>$ sudo yum-config-manager \<br>    –add-repo \<br>    <a href="https://download.docker.com/linux/centos/docker-ce.repo" target="_blank" rel="noopener">https://download.docker.com/linux/centos/docker-ce.repo</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">    </span><br><span class="line">4.安装 docker</span><br></pre></td></tr></table></figure></p><p>$ sudo yum install docker-ce docker-ce-cli containerd.io<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">![logo](docker 简单入门（1）/屏幕快照 2019-03-16 下午6.01.53.png)</span><br><span class="line"></span><br><span class="line">安装完成后</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl start docker<br>设置开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后我们拉去一个 容器 hello-world</span><br></pre></td></tr></table></figure></p><p>$ sudo docker run hello-world<br><code>`</code></p><p>看到下面的输出 就成功了 😯，以上我们 分别演示了 Mac系统和linux系统的 Docker安装 （windows同Mac），可能才接触Docker的朋友 到这里还是没有搞懂 Docker 到底是拿来干嘛的？<br>没关系，后续的文章会从浅入深来介绍Docker ，保管你会爱上它 😁<br><img src="/2019-03-16-docker 简单入门（1）/屏幕快照 2019-03-16 下午6.17.10.png" alt="logo"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2019-03-16-docker 简单入门（1）/7D2913DC-BF91-41C5-8DBE-5DA4CDA001D8.png&quot; alt=&quot;logo&quot;&gt;&lt;/p&gt;
&lt;p&gt; 最近在整理docker的相关知识体系，顺便做些笔记和大家分享下，如果对doc
      
    
    </summary>
    
      <category term="Docker" scheme="https://puruis.github.io/categories/Docker/"/>
    
    
      <category term="Docker" scheme="https://puruis.github.io/tags/Docker/"/>
    
      <category term="入门" scheme="https://puruis.github.io/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>实战Docker搭建自动化部署环境，远程自动部署SpringBoot</title>
    <link href="https://puruis.github.io/2019-02-13-%E5%AE%9E%E6%88%98Docker%E6%90%AD%E5%BB%BA%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%EF%BC%8C%E8%BF%9C%E7%A8%8B%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2SpringBoot/"/>
    <id>https://puruis.github.io/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/</id>
    <published>2019-02-12T16:00:00.000Z</published>
    <updated>2019-03-28T10:13:04.788Z</updated>
    
    <content type="html"><![CDATA[<p>####起因</p><blockquote><p>项目上线运行后,几乎每天都需要更新代码，虽说很简单 ，本地编译，上传，运行，但是每天重复也是一个十分蛋痛的工作，作为一个工程师 一定要杜绝重复劳动。</p></blockquote><p>####<a href="http://www.docker.org.cn" title="Docker" target="_blank" rel="noopener">Docker</a></p><blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote><p>####<a href="https://gitee.com" title="Gitee" target="_blank" rel="noopener">Gitee</a></p><blockquote><p>云端软件开发协作平台</p></blockquote><p>此时 我的测试服务器 已经安装好了 docker 如果你还没有安装 请先安装<br>输入 docker -v  可以查看版本</p><p><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/110740_e2709d98_1289853.png" alt="123"></p><p>####推荐此版本的容器</p><p><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/144903_7c99ee1c_1289853.png" alt="222"></p><ol><li><p>第一步</p><blockquote><p><code>docker pull jenkins/jenkins 下载jenkins</code></p></blockquote></li><li><p>第二步</p><blockquote><p><code>docker images 查看本地镜像</code><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/20180708141046832.png" alt="333"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/2018070814120663.png" alt="444"></p></blockquote></li><li>第三步<br>新建一个jenkins 目录</li></ol><blockquote><p><code>cd /home</code></p></blockquote><blockquote><p><code>mkdir jenkins</code></p></blockquote><blockquote><p>最后运行 <code>docker run -d --name myjenkins -p 49001:8080 -v /home/jenkins_home:/home/jenkins -v /var/maven/apache-maven-3.6.0:/usr/maven/apache-maven-3.6.0 -v /var/java/jdk1.8.0_191:/usr/java/java1.8.0_191 jenkins(这个是镜像名称)</code>， -v 指定目录映射（把宿主机的 java 和 maven环境映射过去,后续需要进入容器 配置jenkins的 java 和maven 环境）</p></blockquote><blockquote><p>ps:其中49001：8080，表示docker内部使用8080端口，服务器使用49001端口，然后将二者映射起来，之后在浏览器访问的时候实际上还是访问服务器的49001端口,注意关闭防火墙 或是 开通端口号</p></blockquote><blockquote><p>此处需要输入 jenkins自动生成的密码</p></blockquote><blockquote><p>输入 <code>docker exec -it myjenkins bash</code> 进入 myjenkins 容器里面</p></blockquote><blockquote><p>输入 find -name initialAdminPassword<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/120327_5f98240a_1289853.png" alt="555"><br>然后 输入cat 命令打印 initialAdminPassword 的内容 复制到页面中</p></blockquote><p>安装成功<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/120526_b047c962_1289853.png" alt="666"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/145037_37387e8d_1289853.png" alt="777"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/120609_40a5db22_1289853.png" alt="888"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/120633_18d43fc3_1289853.png" alt="9999"></p><blockquote><p>在全局工具配置中  配置Java环境 和 maven 环境<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/122401_f7ae7cca_1289853.png" alt="00000"></p></blockquote><hr><blockquote><p>ps: 安装Jenkins后首次访问时由于其他原因【具体未知】会产生离线问题。网上找了个遍还是不能解决，所以只能跳过常用插件安装这步。进入Jenkins后再安装这些插件（我这遇到了，我选择换了一个版本就没事了）</p></blockquote><p>####添加常用的插件<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/20180708141046832.png" alt="ad2d70f43e3242349135378d13b1112ad9b11"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/20180708141138548.png" alt="234123"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/2018070814120663.png" alt="2411234"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/20180708141251349.png" alt="23412342314"></p><h2 id="接下来开始配置-java-及-Maven环境"><a href="#接下来开始配置-java-及-Maven环境" class="headerlink" title="接下来开始配置 java 及 Maven环境"></a>接下来开始配置 java 及 Maven环境</h2><p>JAVA_HOME填写 docker启动命令中 从宿主机映射过来的路径<br>MAVEN也填写 docker启动命令中 从宿主机映射过来的路径<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/145322_6f6731e1_1289853.png" alt="2341234234"></p><p>##新建项目</p><p>如果没有maven项目可选，那么请先安装 Maven Integration plugin 插件<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/165139_96fbeba6_1289853.png" alt="ad2d70f43e93452345135378d13b1112ad9b11"></p><p>我这里使用的是 git<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/165520_f22e9112_1289853.png" alt="453645"><br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/165653_4e6bcb81_1289853.png" alt="567457"></p><p>此处 V2是重点-》需要现在 系统管理的系统设置 中配置<br>Source files：需要上传到服务器的jar包<br>Remove prefix： 需要移除的后缀<br>Remote directory： 远程目录(此处会和 下面配置的 Remote Directory 做拼接)<br>Exec command：文件上传后 执行的命令</p><p>start.sh:</p><pre><code>#!/bin/bashexport JAVA_HOME=/usr/local/java/jdk1.8.0_191echo ${JAVA_HOME}echo &quot;授权当前用户&quot;chmod 777 /opt/project/ixx-web.jar echo &quot;执行....&quot;cd /opt/project/ nohup ${JAVA_HOME}/bin/java -jar ixx-web.jar &gt; aa.out &amp;echo &quot;启动成功&quot;</code></pre><p>stop.sh:</p><pre><code>#!/bin/bashecho &quot;stop SpringBoot BAppApiServerApplication&quot;pid=`ps -ef | grep ixx-web.jar | grep -v grep | awk &apos;{print $2}&apos;`echo “旧应用进程id：$pid”if [ -n &quot;$pid&quot; ]thenkill -9 $pidfi</code></pre><p><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/165751_9f59f39e_1289853.png" alt="24323423">    </p><pre><code>Passphrase ： 服务器登录密码Hostname： 服务器地址Username： 用户名Remote Directory：文件上传的远程目录</code></pre><p><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/170118_5e517695_1289853.png" alt="43534534">   </p><p>然后保存，立即构建<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/170442_5767b20f_1289853.png" alt="546456">   </p><p>系统会开始构建<br><img src="/2019-02-13-实战Docker搭建自动化部署环境，远程自动部署SpringBoot/170958_8c64d259_1289853.png" alt="578567">   </p><p>构建成功，此时 jenkins 已经把 master 分支上的代码 编译-&gt;打包-&gt;上传-&gt;运行成功</p><p>以上是这次给大家分享的 jenkins搭建 及 springBoot 远程自动部署，谢谢大家阅读</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;####起因&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目上线运行后,几乎每天都需要更新代码，虽说很简单 ，本地编译，上传，运行，但是每天重复也是一个十分蛋痛的工作，作为一个工程师 一定要杜绝重复劳动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;####&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="系统运维" scheme="https://puruis.github.io/categories/%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="Docker" scheme="https://puruis.github.io/tags/Docker/"/>
    
      <category term="CI自动化部署" scheme="https://puruis.github.io/tags/CI%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    
      <category term="SpringBoot" scheme="https://puruis.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Lombok：让Java代码更优雅</title>
    <link href="https://puruis.github.io/Lombok%EF%BC%9A%E8%AE%A9Java%E4%BB%A3%E7%A0%81%E6%9B%B4%E4%BC%98%E9%9B%85/"/>
    <id>https://puruis.github.io/Lombok：让Java代码更优雅/</id>
    <published>2018-11-01T16:00:00.000Z</published>
    <updated>2019-03-21T04:38:34.133Z</updated>
    
    <content type="html"><![CDATA[<pre><code>下面是类级别注解@NoArgsConstructor //相当于定义1个无参构造函数@Data //相当于定义了类里所有属性的get set eqauls hashCode toString@RequiredArgsConstructor //一般和@NonNull注解配合使用，表示定义1个包含类里所有声明@NonNull注解的构造函数@Accessors(fluent = true) //表示实体类可以用fluent风格去调用，例如:new Result().success(true).data(123); 这句话里success函数data 函数都是声明注解以后自动生成的，并且都返回当前类自身。@FieldDefaults(level = AccessLevel.PRIVATE) //所有属性默认访问级别都是private ,省的挨个属性去写了，如果有10个属性，9个都是private ，1个是public ,可以单独覆盖.如果单独那个是包级别访问权限的，可以通过加上@PackagePrivate注解去覆盖@UtilityClass //声明这个注解，会自动为该类生成1个私有无参构造函数，构造函数内部会直接抛异常，表示这个类是1个工具类，无法实例化@Log4j2 //声明log4j2注解，会自动为该类创建1个 log属性，避免手动创建，lombok还支持slf4j,log4j1.x commons log ，jdk原生的log,都会有相应的注解支持 .</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;下面是类级别注解
@NoArgsConstructor //相当于定义1个无参构造函数
@Data //相当于定义了类里所有属性的get set eqauls hashCode toString
@RequiredArgsConstructor //一般和@
      
    
    </summary>
    
      <category term="Lombok" scheme="https://puruis.github.io/categories/Lombok/"/>
    
    
      <category term="JAVA" scheme="https://puruis.github.io/tags/JAVA/"/>
    
      <category term="Lombok" scheme="https://puruis.github.io/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>Got error 28 from storage engine 解决记录</title>
    <link href="https://puruis.github.io/Got%20error%2028%20from%20storage%20engine%20%E8%A7%A3%E5%86%B3%E8%AE%B0%E5%BD%95/"/>
    <id>https://puruis.github.io/Got error 28 from storage engine 解决记录/</id>
    <published>2018-08-26T16:00:00.000Z</published>
    <updated>2019-03-21T04:39:30.703Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>周一早上来上班，刚打开电脑，同事就接到的 客户的投诉，数据提交不了。<br>同事问我，是不是服务挂了，  我赶忙连接上服务器，发现服务并没有挂，查询数据时就卡住了，第一个反应，<br>？？？？ 是不是 数据 锁住了，打开Navicat 查询 爆出 下面这件 橙装，<br>没遇到过，只能百度，</p></blockquote><p>原因：存储引擎不够，无法执行此SQL语句。(大致理解是磁盘空间不足)</p><p><img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1535364022728&amp;di=f9739f006bff045911dc498cefdcc2d5&amp;imgtype=0&amp;src=http%3A%2F%2Fs16.sinaimg.cn%2Fbmiddle%2Fa1409149tc03587ddf4cf%26690" alt="image"><br><a id="more"></a><br>网上扣的图，出错的忘记截图了</p><p>验证:</p><p><img src="https://oscimg.oschina.net/oscnet/7e7f7db4302bdd925605ad65c705d2f477a.jpg" alt="image"></p><p>上图是解决后 截图的， 出错时,/dev/sda2 Use% 是 100%</p><ul><li>/dev/sda这是Linux系统下的设备文件，类似Windows系统上面的本地磁盘、U盘、光驱等设备</li><li>设备文件系统</li><li>tmpfs（temporary filesystem）是Linux特有的文件系统，标准挂载点是/dev/shm，默认大小是实际内存的一半，如下图所示。当然，用户也可以将tmpfs挂载在其他地方。tmpfs可以使用物理内存，也可以使用swap交换空间。tmpfs有些像虚拟磁盘（ramdisk）</li></ul><p>解决方案：删除一些临时文件或是不用的文件</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;周一早上来上班，刚打开电脑，同事就接到的 客户的投诉，数据提交不了。&lt;br&gt;同事问我，是不是服务挂了，  我赶忙连接上服务器，发现服务并没有挂，查询数据时就卡住了，第一个反应，&lt;br&gt;？？？？ 是不是 数据 锁住了，打开Navicat 查询 爆出 下面这件 橙装，&lt;br&gt;没遇到过，只能百度，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原因：存储引擎不够，无法执行此SQL语句。(大致理解是磁盘空间不足)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://timgsa.baidu.com/timg?image&amp;amp;quality=80&amp;amp;size=b9999_10000&amp;amp;sec=1535364022728&amp;amp;di=f9739f006bff045911dc498cefdcc2d5&amp;amp;imgtype=0&amp;amp;src=http%3A%2F%2Fs16.sinaimg.cn%2Fbmiddle%2Fa1409149tc03587ddf4cf%26690&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="https://puruis.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Mysql" scheme="https://puruis.github.io/tags/Mysql/"/>
    
      <category term="磁盘" scheme="https://puruis.github.io/tags/%E7%A3%81%E7%9B%98/"/>
    
      <category term="Linux" scheme="https://puruis.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>手动实现数据库连接池</title>
    <link href="https://puruis.github.io/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://puruis.github.io/手动实现数据库连接池/</id>
    <published>2018-08-21T16:00:00.000Z</published>
    <updated>2019-03-21T06:38:51.127Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://gitee.com/zprsss/pool.git" target="_blank" rel="noopener">https://gitee.com/zprsss/pool.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://gitee.com/zprsss/pool.git&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://gitee.com/zprsss/pool.git&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="JAVA" scheme="https://puruis.github.io/categories/JAVA/"/>
    
    
      <category term="数据库连接池" scheme="https://puruis.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="多线程" scheme="https://puruis.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMq 入门</title>
    <link href="https://puruis.github.io/ActiveMq%20%E5%85%A5%E9%97%A8/"/>
    <id>https://puruis.github.io/ActiveMq 入门/</id>
    <published>2018-08-09T16:00:00.000Z</published>
    <updated>2019-03-21T04:37:06.803Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们需要下载 ActiveMq 然后双击activemq.bat 启动 ActiveMq</p><p><img src="https://static.oschina.net/uploads/space/2017/0817/164714_tb08_3394890.png" alt="image"><br><!--更多...--><br>如下启动成功！<br><img src="https://static.oschina.net/uploads/space/2017/0817/164828_KyAW_3394890.png" alt="image"></p><p>然后访问 <a href="http://localhost:8161/admin/" target="_blank" rel="noopener">http://localhost:8161/admin/</a>    ActiveMq提供的一个管理界面</p><p><img src="https://static.oschina.net/uploads/space/2017/0817/164925_aKLs_3394890.png" alt="image"></p><p>然后 我使用JAVA来操作<br>首先,我们创一个 消息发送者</p><pre><code>public class Sender {    public static void main(String[] args) throws JMSException {        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(                ActiveMQConnectionFactory.DEFAULT_USER,                ActiveMQConnectionFactory.DEFAULT_PASSWORD,                ActiveMQConnectionFactory.DEFAULT_BROKER_URL);        //创建一个连接        Connection connection = activeMQConnectionFactory.createConnection();        //开启连接        connection.start();        //创建会话        // 1.是否启动 事务    2.签收模式        Session session = connection.createSession(Boolean.FALSE, Session.AUTO_ACKNOWLEDGE);        //创建 一个队列        Destination destination = session.createQueue(&quot;queue1&quot;);        //通过 session 创建 发送消息的生产者/接收消息的 消费者        MessageProducer producer = session.createProducer(destination);        //设置持久化        producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);        TextMessage textMessage = session.createTextMessage();        textMessage.setText(&quot;hello active!&quot;);        //发送        producer.send(textMessage);        //释放资源        if(null != connection){            connection.close();        }    }}</code></pre><p>当然我们也需要一个接收者 </p><pre><code>public class Receiver {    public static void main(String[] args) {        // ConnectionFactory ：连接工厂，JMS 用它创建连接        ConnectionFactory connectionFactory;        // Connection ：JMS 客户端到JMS Provider 的连接        Connection connection = null;        // Session： 一个发送或接收消息的线程        Session session;        // Destination ：消息的目的地;消息发送给谁.        Destination destination;        // 消费者，消息接收者        MessageConsumer consumer;        connectionFactory = new ActiveMQConnectionFactory(                ActiveMQConnection.DEFAULT_USER,                ActiveMQConnection.DEFAULT_PASSWORD,                ActiveMQConnectionFactory.DEFAULT_BROKER_URL);        try {            // 构造从工厂得到连接对象            connection = connectionFactory.createConnection();            // 启动            connection.start();            // 获取操作连接            session = connection.createSession(Boolean.FALSE,                    Session.AUTO_ACKNOWLEDGE);            destination = session.createQueue(&quot;queue1&quot;);            consumer = session.createConsumer(destination);            while (true) {                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s                TextMessage message = (TextMessage) consumer.receive(100000);                if (null != message) {                    System.out.println(&quot;收到消息&quot; + message.getText());                } else {                    break;                }            }        } catch (Exception e) {            e.printStackTrace();        } finally {            try {                if (null != connection)                    connection.close();            } catch (Throwable ignore) {            }        }    }}</code></pre><p>运行结果</p><p><img src="https://static.oschina.net/uploads/space/2017/0817/165120_qElJ_3394890.png" alt="image"></p><p>代码-》》 <a href="https://git.oschina.net/zprsss/ActiveMqDemo.git" target="_blank" rel="noopener">https://git.oschina.net/zprsss/ActiveMqDemo.git</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先我们需要下载 ActiveMq 然后双击activemq.bat 启动 ActiveMq&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2017/0817/164714_tb08_3394890.pn
      
    
    </summary>
    
      <category term="ActiveMq" scheme="https://puruis.github.io/categories/ActiveMq/"/>
    
    
      <category term="ActiveMq" scheme="https://puruis.github.io/tags/ActiveMq/"/>
    
  </entry>
  
  <entry>
    <title>nginx 配置阿里云免费证书</title>
    <link href="https://puruis.github.io/nginx%20%E9%85%8D%E7%BD%AE%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%8D%E8%B4%B9%E8%AF%81%E4%B9%A6/"/>
    <id>https://puruis.github.io/nginx 配置阿里云免费证书/</id>
    <published>2018-08-08T16:00:00.000Z</published>
    <updated>2019-03-21T04:36:16.927Z</updated>
    
    <content type="html"><![CDATA[<p>申请阿里云证书 绑定自己的域名<br><img src="https://oscimg.oschina.net/oscnet/b7a0f06cdcd18bc465eac507a26675a9cb0.jpg" alt="image"><br><a id="more"></a></p><p>然后下载证书<br><img src="https://oscimg.oschina.net/oscnet/504e6784feffbb19e8928f8f86a4b6ad28b.jpg" alt="image"></p><p>==重点：服务器打开443端口==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后把下载的证书 放到nginx的安装目录,新建一个cert目录，把证书放到里面</span><br></pre></td></tr></table></figure></p><p><img src="https://oscimg.oschina.net/oscnet/c09831d462620a2ee7f5333882e46434afb.jpg" alt="image"></p><p>然后保存 重启 nginx</p><p>访问你的 https 站点 类似<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;申请阿里云证书 绑定自己的域名&lt;br&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/b7a0f06cdcd18bc465eac507a26675a9cb0.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="支付" scheme="https://puruis.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="https" scheme="https://puruis.github.io/tags/https/"/>
    
      <category term="阿里云证书" scheme="https://puruis.github.io/tags/%E9%98%BF%E9%87%8C%E4%BA%91%E8%AF%81%E4%B9%A6/"/>
    
      <category term="nginx" scheme="https://puruis.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper(四)-实战</title>
    <link href="https://puruis.github.io/Zookeeper(%E5%9B%9B)-%E5%AE%9E%E6%88%98/"/>
    <id>https://puruis.github.io/Zookeeper(四)-实战/</id>
    <published>2018-08-07T16:00:00.000Z</published>
    <updated>2019-03-21T06:33:55.933Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://static.oschina.net/uploads/space/2017/0822/232711_gKvk_3394890.png" alt="image"><br><a id="more"></a><br>注册到我自己的测试服务器上的zookeeper，然后我们去看看 zookeeper的节点是怎么样的<br><img src="https://static.oschina.net/uploads/space/2017/0822/232823_KFAK_3394890.png" alt="image"></p><p>除了一个默认的zookeeper的节点 ，多了一个dubbo(持久节点)的节点，然后我们去看看dubbo下面的节点是啥</p><p><img src="https://static.oschina.net/uploads/space/2017/0822/232921_TYQZ_3394890.png" alt="image"></p><p>可以看到 dubbo下面的节点全是 java的service类的权限定包名，O(∩_∩)O~，想看其它信息，自己也去试试吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2017/0822/232711_gKvk_3394890.png&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://puruis.github.io/categories/Zookeeper/"/>
    
    
      <category term="分布式" scheme="https://puruis.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="https://puruis.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper入门(三)</title>
    <link href="https://puruis.github.io/Zookeeper(%E4%B8%89)/"/>
    <id>https://puruis.github.io/Zookeeper(三)/</id>
    <published>2018-08-06T16:00:00.000Z</published>
    <updated>2019-03-21T06:33:27.303Z</updated>
    
    <content type="html"><![CDATA[<p>1.集群环境搭建 - 启动<br>    修改zooo.cfg 配置文件 如下<br><img src="https://static.oschina.net/uploads/space/2017/0819/215436_PIlt_3394890.png" alt="image"></p><a id="more"></a><p>为了方便，我这搭建的只是一个伪集群环境</p><p>2888 表示 心跳检测端口</p><p>3888 表示 领导选举，用于投票的端口</p><p>2.使用命令行客户端连接Zookeeper</p><p>$ bin/zkCli.sh 会出现以下信息<br><img src="https://static.oschina.net/uploads/space/2017/0819/221238_r6YL_3394890.png" alt="image"></p><p>表示成功连接， 若是想连接别的服务器上的zookeeper 则 使用如下命令:</p><p>$ bin/zkCli.sh -server <ip>:<port></port></ip></p><p>好了，我们来通过命令行来操作zookeeper吧。</p><p>我不知道命令啊？？？？   没关系，  叫help（帮助）</p><p><img src="https://static.oschina.net/uploads/space/2017/0819/221534_98B5_3394890.png" alt="image"></p><p>以上命令大多数是针对ZNode节点进行操作</p><p>1.列出子节点<br>命令格式: ls path [watch]</p><p>那么我们先列出根节点的所有子节点:<br><img src="https://static.oschina.net/uploads/space/2017/0819/221858_H8s6_3394890.png" alt="image"></p><p>默认根节点下有一个 zookeeper的子节点，它作为Zookeeper的保留节点，我们一般不使用它</p><p>另外我们还可以使用 ls2</p><p>来看看<br><img src="https://static.oschina.net/uploads/space/2017/0819/222103_1TTK_3394890.png" alt="image"></p><p>cZxid : 表示节点创建时的事务ID （每个客户点的请求都会形成一个事务）</p><p>ctime : 表示节点创建的时间</p><p>mZxid : 表示最后一次修改节点的事务ID</p><p>mtime : 最后一次修改节点的时间</p><p>pZxid ： 表示最后一次修改父节点的事务ID</p><p>cversion : 表示子节点的版本号</p><p>dataVersion : 表示节点所包含数据的版本号(每个数据都有自己的版本，它与节点的版本不一样)</p><p>aclVersion : 表示节点的ACL 权限版本号(权限也有自己的版本)</p><p>ephemeralOwner : 表示临时会话的ID</p><p>dataLength : 表示节点所包含的数据内容长度</p><p>numChildren : 表示当前节点的子节点数</p><p>以上信息都称为 Stat(统计)</p><p>2.判断子节点是否存在<br>判断foo 节点是否存在</p><pre><code>stat /foo</code></pre><p><img src="https://static.oschina.net/uploads/space/2017/0819/222938_pVXg_3394890.png" alt="image"></p><p>可以看出 该节点不存在</p><p>3.创建节点<br>create [-s] [-e] path data acl</p><p>-s 用于指定该节点是否为顺序节点</p><p>-c 用于指定该节点是否为临时节点</p><p>最后一个acl 用于权限控制  zookeeper 内部提供了一个Access Contronl List(访问权限控制列表，简称ACL)，默认情况下不做任何权限控制.</p><p>我们来创建一个 hello的节点 数据内容为 hello world<br><img src="https://static.oschina.net/uploads/space/2017/0819/223415_Ky0f_3394890.png" alt="image"></p><p>创建成功!</p><p>4.获取节点<br>get path [watch]<br><img src="https://static.oschina.net/uploads/space/2017/0819/223521_cUFY_3394890.png" alt="image"></p><p>即可获得 该节点的 Stat信息</p><p>5.更新节点信息<br>set path data [version]<br><img src="https://static.oschina.net/uploads/space/2017/0819/223646_4ULW_3394890.png" alt="image"></p><p>大家可以看到Stat信息产生了变化 版本从0变成了1 其它数据也产生了变化</p><p>6.删除节点<br>delete path [version]<br><img src="https://static.oschina.net/uploads/space/2017/0819/223847_hUPT_3394890.png" alt="image"></p><p>该命令执行后不会有任何提示，注意只有该节点没有子节点时才能删除成功，否则将给出”Node not empty”</p><p>但是我们可以通过 rmr path  一次性删除该节点及下面的所有子节点</p><p>下次继续分享  通过java 来操作Zookeeper!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.集群环境搭建 - 启动&lt;br&gt;    修改zooo.cfg 配置文件 如下&lt;br&gt;&lt;img src=&quot;https://static.oschina.net/uploads/space/2017/0819/215436_PIlt_3394890.png&quot; alt=&quot;image&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://puruis.github.io/categories/Zookeeper/"/>
    
    
      <category term="分布式" scheme="https://puruis.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="https://puruis.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper入门(二)</title>
    <link href="https://puruis.github.io/Zookeeper%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>https://puruis.github.io/Zookeeper入门(二)/</id>
    <published>2018-08-05T16:00:00.000Z</published>
    <updated>2019-03-21T06:33:00.517Z</updated>
    
    <content type="html"><![CDATA[<p>1.下载Zookeeper:<br>            下载地址: <a href="http://www.apache.org/dyn/closer.cgi/zookeeper/" target="_blank" rel="noopener">http://www.apache.org/dyn/closer.cgi/zookeeper/</a></p><pre><code>    linux 下执行：     wget http://apache.fayea.com/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz即可下载成功!</code></pre><p>tar zxvf zookeeper-3.4.10.tar.gz<br><a id="more"></a><br>以上命令解压文件</p><p>   第一步修改 配置文件：</p><pre><code>Zookeeper 默认给了一个zoo_sample.cfg 的实例配置文件，我们需要复制并将其命名为zoo.cfg </code></pre><p>   这样做: $ cp conf/zoo_sample.cfg conf/zoo.cfg </p><p>让我们看看里面的配置参数：<br><img src="https://static.oschina.net/uploads/space/2017/0819/212221_SZNV_3394890.png" alt="image"></p><p>tickTime=2000</p><p>initLimit=10</p><p>syncLimit=5</p><p>dataDir=/tmp/zookeeper</p><p>clientPort=2181</p><p>我们一次来解释：</p><pre><code>tickTime : 成为滴答时间，用于配置zookeeper中的最小时间单元的长度，实际上zookeeper中很多时间间隔都是使用tickTime的配置来表示。例如 zookeeper中会话超时数 是 2*tickTime 该值默认为3000msinitLimit : 用于配置Leader 节点等待Follower 节点启动并完成数据同步的时间syncLimit : 心跳检测时间dataDir : 快照文件目录clientPort ： 对外端口</code></pre><p>2.启动Zookeeper<br>    $ bin/zkServer.sh start</p><p>即可启动服务</p><p><img src="https://static.oschina.net/uploads/space/2017/0819/212936_9NyA_3394890.png" alt="image"></p><p>3.验证Zookeeper服务是否有效<br>    可以执行以下脚本来获取zookeeper的状态</p><p> $ bin/zkServer.sh status</p><p>ZooKeeper JMX enabled by default<br>Using config: /zpr/zookeeper-3.4.10/bin/../conf/zoo.cfg<br>Mode: standalone</p><p>输出以上信息 就表示zookeeper 服务有效。</p><p>此外我们还可以用 telnet 命令来验证zookeeper服务的有效性，查看本机是否有安装telnet（centOS5默认有安装telnet）</p><p>一、查看本机是否安装telnet</p><p>#rpm -qa | grep telnet</p><p>如果什么都不显示。说明你没有安装telnet</p><p>二、开始安装</p><p>yum install  xinetd</p><p>yum install telnet</p><p>yum install telnet-server</p><p>三、装好telnet服务之后，默认是不开启服务的，下面我们需要修改文件来开启服务。</p><p>vim  /etc/xinetd.d/telnet    修改 disable = yes 为 disable = no</p><p>四、需要激活xinetd服务</p><h1 id="service-xinetd-restart-或者-etc-rc-d-init-d-xinetd-restart"><a href="#service-xinetd-restart-或者-etc-rc-d-init-d-xinetd-restart" class="headerlink" title="service  xinetd restart    或者  #/etc/rc.d/init.d/xinetd  restart"></a>service  xinetd restart    或者  #/etc/rc.d/init.d/xinetd  restart</h1><p>然后 我们继续 执行 telnet 127.0.0.1 2181</p><p>即可看到 </p><p> <img src="https://static.oschina.net/uploads/space/2017/0819/214730_g824_3394890.png" alt="image"></p><p>上图没还打印出 zookeeper的状态  我这网速太差了。。。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1.下载Zookeeper:&lt;br&gt;            下载地址: &lt;a href=&quot;http://www.apache.org/dyn/closer.cgi/zookeeper/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.apache.org/dyn/closer.cgi/zookeeper/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    linux 下执行：

     wget http://apache.fayea.com/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz

即可下载成功!
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;tar zxvf zookeeper-3.4.10.tar.gz&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://puruis.github.io/categories/Zookeeper/"/>
    
    
      <category term="分布式" scheme="https://puruis.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="https://puruis.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 入门 (一)</title>
    <link href="https://puruis.github.io/Zookeeper%20%E5%85%A5%E9%97%A8%20(%E4%B8%80)/"/>
    <id>https://puruis.github.io/Zookeeper 入门 (一)/</id>
    <published>2018-08-04T16:00:00.000Z</published>
    <updated>2019-03-21T06:52:46.128Z</updated>
    
    <content type="html"><![CDATA[<p>Zookeeper 介绍<br>    Zookeeper是软件世界的一名管理者，它被用来提供分布式环境下的协调服务， Yahoo公司使用JAVA 语言开发了Zookeeper，它是Hadoop项目中的子项目，基于Google的Chubby 的开源实现，在Hadoop，HBase，Kafka等技术中充当了核心角色，它的目标就是将那些复杂且容易出错的分布式一致性服务加以封装，形成一个高效且可靠的服务，并为用户提供了一系列简单易用的接口。</p><pre><code>Zookeeper 官网 ：http://zookeeper.apache.org/</code></pre><a id="more"></a>    <p>Zookeeper 一般以集群的方式对外提供服务，一个集群包括多个节点，每个节点对应一个zookeeper服务器，所有的节点共同对外提供服务，整个集群对分布式数据一致性提供了全面的支持，具体包含如下五个特性：</p><pre><code>1.顺序性        好比一个队列，先进先出，一个个排队2.原子性        和事务的原子性一致3.单一性        Zokeeper 各个节点间 不可能出现两种不一样的数据状态4.可靠性        一旦服务器数据发生变化，就会立即被储存起来。5.实时性        服务器的请求被处理，客户端能够及时得到最新数据状态</code></pre><p>Zookeeper 树状模型<br>    Zookeeper 内部有一个树状的内存模型，类型文件系统，有若干个目录，每一个目录都有自己的文件，只是在Zookeeper中把这个统称为ZNode ，每个ZNode有对应的路径及其包含的数据，ZNode 由Zookeeper 客户端来创建，客户端建立连接后， 服务端会创建一个session， 客户端所有操作都将在这个sessiuon(会话)中进行</p><p><img src="https://static.oschina.net/uploads/space/2017/0819/205659_51h8_3394890.png" alt="image"></p><p>ZNode 有四类节点：</p><pre><code>Persistent(持久节点)            会话结束后，该节点不会删除Persistent Sequential(之久顺序节点)   会话结束后，该节点不会删除 且节点名中自带自增后缀Ephemeral(临时节点)           会话结束被删除Ephemeral Sequentia(临时顺序节点)   会话结束被删除， 且节点名中自带自增后缀</code></pre><p>Persistent  AND Persistent Sequential 才能有子节点</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zookeeper 介绍&lt;br&gt;    Zookeeper是软件世界的一名管理者，它被用来提供分布式环境下的协调服务， Yahoo公司使用JAVA 语言开发了Zookeeper，它是Hadoop项目中的子项目，基于Google的Chubby 的开源实现，在Hadoop，HBase，Kafka等技术中充当了核心角色，它的目标就是将那些复杂且容易出错的分布式一致性服务加以封装，形成一个高效且可靠的服务，并为用户提供了一系列简单易用的接口。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Zookeeper 官网 ：http://zookeeper.apache.org/
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Zookeeper" scheme="https://puruis.github.io/categories/Zookeeper/"/>
    
    
      <category term="分布式" scheme="https://puruis.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="高可用" scheme="https://puruis.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>支付宝对接-查询对账单下载地址接口 遇到的坑</title>
    <link href="https://puruis.github.io/%E6%94%AF%E4%BB%98%E5%AE%9D%E5%AF%B9%E6%8E%A5-%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B4%A6%E5%8D%95%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E6%8E%A5%E5%8F%A3%20%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/"/>
    <id>https://puruis.github.io/支付宝对接-查询对账单下载地址接口 遇到的坑/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2019-03-21T06:40:04.770Z</updated>
    
    <content type="html"><![CDATA[<p>**因为公司后面准备开发财务系统，那么支付肯定是必不可少的，本来想找个随手即用的封装好的支付来直接使用，但是在网上找了一圈，没有找到太中意的，于是准备利用周末时间自己来封装一个 开箱即用的 支付模块。</p><hr><p><img src="https://oscimg.oschina.net/oscnet/c4866fce0956f9f4d41f94c5da60cb25874.jpg" alt="image"><br><a id="more"></a></p><p>说到开箱即用，我第一想到了springboot，于是准备准备写一个</p><h1 id="spring-boot-starter-pay"><a href="#spring-boot-starter-pay" class="headerlink" title="spring-boot-starter-pay"></a>spring-boot-starter-pay</h1><p>简单配置即可使用<br><img src="https://oscimg.oschina.net/oscnet/9b404f812ce42440184221551dc27e3996a.jpg" alt="image"></p><h3 id="注入service-直接调用"><a href="#注入service-直接调用" class="headerlink" title="注入service 直接调用"></a>注入service 直接调用</h3><p><img src="https://oscimg.oschina.net/oscnet/713e1c5289e0a691d38e69ed2249f0ea110.jpg" alt="image"></p><p>前面的接口封装 基本都是顺风顺水</p><h1 id="alipay-data-dataservice-bill-downloadurl-query-查询对账单下载地址"><a href="#alipay-data-dataservice-bill-downloadurl-query-查询对账单下载地址" class="headerlink" title="alipay.data.dataservice.bill.downloadurl.query(查询对账单下载地址)"></a>alipay.data.dataservice.bill.downloadurl.query(查询对账单下载地址)</h1><p>测试时一直 参数不合法 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;alipay_data_dataservice_bill_downloadurl_query_response&quot;: &#123;</span><br><span class="line">&quot;code&quot;: &quot;40004&quot;,</span><br><span class="line">&quot;msg&quot;: &quot;Business Failed&quot;,</span><br><span class="line">&quot;sub_code&quot;: &quot;isv.invalid_arguments&quot;,</span><br><span class="line">&quot;sub_msg&quot;: &quot;入参不合法&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>莫名其妙了，哪里参数不合法了，一开始 我还真认为是我参数传错了，好半天都没解决，问题出在哪呢？</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项:"></a>注意事项:</h1><ul><li>这个接口是下载离线账单的，需要T+1天生成账单，不能查询当日或者是当月的账单，如果日期是当天或者是当月的会返回“参数不合法”； </li><li>下载对账单地址接口只有当面付接口可以下载trade类型的账单，其他支付接口只能下载signcustomer 这个类型的 </li></ul><p>等我把代码封装完善，会上传到码云上， springBoot-Pay 开箱即用 欢迎期待</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;**因为公司后面准备开发财务系统，那么支付肯定是必不可少的，本来想找个随手即用的封装好的支付来直接使用，但是在网上找了一圈，没有找到太中意的，于是准备利用周末时间自己来封装一个 开箱即用的 支付模块。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/c4866fce0956f9f4d41f94c5da60cb25874.jpg&quot; alt=&quot;image&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="支付" scheme="https://puruis.github.io/categories/%E6%94%AF%E4%BB%98/"/>
    
    
      <category term="JAVA" scheme="https://puruis.github.io/tags/JAVA/"/>
    
      <category term="支付宝" scheme="https://puruis.github.io/tags/%E6%94%AF%E4%BB%98%E5%AE%9D/"/>
    
      <category term="账单" scheme="https://puruis.github.io/tags/%E8%B4%A6%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>利用 jconsole 查看远程服务器的运行情况</title>
    <link href="https://puruis.github.io/%E5%88%A9%E7%94%A8%20jconsole%20%E6%9F%A5%E7%9C%8B%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E8%BF%90%E8%A1%8C%E6%83%85%E5%86%B5/"/>
    <id>https://puruis.github.io/利用 jconsole 查看远程服务器的运行情况/</id>
    <published>2018-07-06T16:00:00.000Z</published>
    <updated>2019-03-21T06:37:39.517Z</updated>
    
    <content type="html"><![CDATA[<p> jconsole  是JDK 提供的一个工具 可以。。。  如下图</p><p> <img src="https://static.oschina.net/uploads/space/2017/0817/175732_r49U_3394890.png" alt="image"></p><p> 如此好的东西 为什么不知道用呢？  哈哈哈  ++其实它一直在你的眼皮子底下++ </p><p> <img src="https://static.oschina.net/uploads/space/2017/0817/175824_hG6F_3394890.png" alt="image"></p><p> 它可以帮我们 了解服务器的服务情况  并且是 UI 的方式显示 ，更加直观</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; jconsole  是JDK 提供的一个工具 可以。。。  如下图&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://static.oschina.net/uploads/space/2017/0817/175732_r49U_3394890.png&quot; alt=&quot;ima
      
    
    </summary>
    
      <category term="Proxy" scheme="https://puruis.github.io/categories/Proxy/"/>
    
    
      <category term="JAVA" scheme="https://puruis.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>关于 Proxy 续集 -代码重构</title>
    <link href="https://puruis.github.io/%E5%85%B3%E4%BA%8E%20Proxy%20%E7%BB%AD%E9%9B%86%20-%E4%BB%A3%E7%A0%81%E9%87%8D%E6%9E%84/"/>
    <id>https://puruis.github.io/关于 Proxy 续集 -代码重构/</id>
    <published>2018-07-06T16:00:00.000Z</published>
    <updated>2019-03-21T06:37:09.518Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们说了静态代理，那么有静态代理自然也就有动态代理咯，这次我们主要说 javaJDK给我提供的 一套动态代理。</p><pre><code>老规矩先看代码,</code></pre><p>接口类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Hello &#123;</span><br><span class="line">    public void say(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class HelloImpl implements Hello&#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void say(String name) &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        DynamicProxy dynamicProxy = new DynamicProxy(new HelloImpl());</span><br><span class="line">        Hello proxy = dynamicProxy.getProxy();</span><br><span class="line">        proxy.say(&quot;一战成佛&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class DynamicProxy implements InvocationHandler&#123;</span><br><span class="line">    private Object object;</span><br><span class="line">    public DynamicProxy(Object object)&#123;</span><br><span class="line">        this.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">    public &lt;T&gt; T getProxy()&#123;</span><br><span class="line">        return (T)Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),this);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">        berofe();</span><br><span class="line">        Object invoke = method.invoke(object, args);</span><br><span class="line">        after();</span><br><span class="line">        return invoke;</span><br><span class="line">    &#125;</span><br><span class="line">    public void berofe()&#123;</span><br><span class="line">        System.out.println(&quot;before&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void after()&#123;</span><br><span class="line">        System.out.println(&quot;after&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注释 很好理解 动态代理，总结下 java提供的动态代理</p><pre><code>优点:    1.被代理类变动，代理不需要变动    2.更加灵活缺点:    1.依赖接口，必须要有接口 才能代理 被代理对象</code></pre><p>万一 需要代理的对象没有接口，那就玩玩拉，所以下一篇 开始说CGLIB 这也是springAop实现动态代理的依赖，等着感受它的强大魅力吧<img src="http://img.baidu.com/hi/jx2/j_0035.gif" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上篇文章我们说了静态代理，那么有静态代理自然也就有动态代理咯，这次我们主要说 javaJDK给我提供的 一套动态代理。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;老规矩先看代码,
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接口类：&lt;/p&gt;
&lt;figure class=&quot;highlight pla
      
    
    </summary>
    
      <category term="Proxy" scheme="https://puruis.github.io/categories/Proxy/"/>
    
    
      <category term="JAVA" scheme="https://puruis.github.io/tags/JAVA/"/>
    
      <category term="Aop" scheme="https://puruis.github.io/tags/Aop/"/>
    
  </entry>
  
</feed>
